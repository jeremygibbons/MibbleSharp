// <copyright file="NFAState.cs" company="None">
//    <para>
//    This program is free software: you can redistribute it and/or
//    modify it under the terms of the BSD license.</para>
//    <para>
//    This work is distributed in the hope that it will be useful, but
//    WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</para>
//    <para>
//    See the LICENSE.txt file for more details.</para>
//    Original code as generated by Grammatica 1.6 Copyright (c) 
//    2003-2015 Per Cederberg. All rights reserved.
//    Updates Copyright (c) 2016 Jeremy Gibbons. All rights reserved
// </copyright>

namespace PerCederberg.Grammatica.Runtime.NFA
{
    using System.Collections.Generic;
    using System.Linq;
    using PerCederberg.Grammatica.Runtime;

    /// <summary>
    /// An NFA state. The NFA consists of a series of states, each
    /// having zero or more transitions to other states.
    /// </summary>
    internal class NFAState
    {
        /// <summary>
        /// The optional state value (if it is a final state).
        /// </summary>    
        private TokenPattern value = null;

        /// <summary>
        /// The incoming transitions to this state.
        /// </summary>
        private List<NFATransition> incoming = new List<NFATransition>();

        /// <summary>
        /// The outgoing transitions from this state.
        /// </summary>
        private List<NFATransition> outgoing = new List<NFATransition>();

        /// <summary>
        /// The outgoing epsilon transitions flag.
        /// </summary>
        private bool epsilonOut = false;

        /// <summary>
        /// Gets a value indicating whether this state has any incoming or outgoing
        /// transitions.
        /// </summary>
        public bool HasTransitions
        {
            get
            {
                return this.incoming.Count > 0 || this.outgoing.Count > 0;
            }
        }

        /// <summary>
        /// Gets a value indicating whether all outgoing transitions only match ASCII
        /// characters.
        /// </summary>
        public bool IsAsciiOutgoing
        {
            get
            {
                return this.outgoing.All(o => o.IsAscii);
            }
        }

        /// <summary>
        /// Gets a value indicating whether the state has outgoing epsilon 
        /// transitions
        /// </summary>
        internal bool EpsilonOut
        {
            get
            {
                return this.epsilonOut;
            }
        }

        /// <summary>
        /// Gets the list of incoming transitions to the state
        /// </summary>
        internal List<NFATransition> Incoming
        {
            get
            {
                return this.incoming;
            }
        }

        /// <summary>
        /// Gets the list of outgoing transitions from the state.
        /// </summary>
        internal List<NFATransition> Outgoing
        {
            get
            {
                return this.outgoing;
            }
        }

        /// <summary>
        /// Gets or sets the optional state value (if this is a final state)
        /// </summary>
        internal TokenPattern Value
        {
            get
            {
                return this.value;
            }

            set
            {
                this.value = value;
            }
        }

        /// <summary>
        /// Adds a new incoming transition.
        /// </summary>
        /// <param name="trans">The transition to add</param>
        public void AddIn(NFATransition trans)
        {
            this.incoming.Add(trans);
        }

        /// <summary>
        /// Adds a new outgoing character transition. If the target
        /// state specified was null and an identical transition
        /// already exists, it will be reused and its target returned.
        /// </summary>
        /// <param name="ch">The character to match</param>
        /// <param name="ignoreCase">The case-insensitive flag</param>
        /// <param name="state">The target state, or null</param>
        /// <returns>The transition target state</returns>
        public NFAState AddOut(char ch, bool ignoreCase, NFAState state)
        {
            if (ignoreCase)
            {
                if (state == null)
                {
                    state = new NFAState();
                }

                this.AddOut(new NFACharTransition(char.ToLower(ch), state));
                this.AddOut(new NFACharTransition(char.ToUpper(ch), state));
                return state;
            }
            else
            {
                if (state == null)
                {
                    state = this.FindUniqueCharTransition(ch);
                    if (state != null)
                    {
                        return state;
                    }

                    state = new NFAState();
                }

                return this.AddOut(new NFACharTransition(ch, state));
            }
        }

        /// <summary>
        /// Adds a new outgoing transition.
        /// </summary>
        /// <param name="trans">The transition to add</param>
        /// <returns>The transition target state</returns>
        public NFAState AddOut(NFATransition trans)
        {
            this.outgoing.Add(trans);

            if (trans is NFAEpsilonTransition)
            {
                this.epsilonOut = true;
            }

            return trans.State;
        }

        /// <summary>
        /// Merges all the transitions in this state into another
        /// state.
        /// </summary>
        /// <param name="state">The state to merge into</param>
        public void MergeInto(NFAState state)
        {
            foreach (var inTrans in this.incoming)
            {
                state.AddIn(inTrans);
                inTrans.State = state;
            }

            this.incoming = null;

            foreach (var outTrans in this.outgoing)
            {
                state.AddOut(outTrans);
            }

            this.outgoing = null;
        }

        /// <summary>
        /// Attempts a match on each of the transitions leading from
        /// this state. If a match is found, its state will be added
        /// to the queue. If the initial match flag is set, epsilon
        /// transitions will also be matched (and their targets called
        /// recursively).
        /// </summary>
        /// <param name="ch">The character to match</param>
        /// <param name="queue">The state queue</param>
        /// <param name="initial">The initial match flag</param>
        public void MatchTransitions(char ch, NFAStateQueue queue, bool initial)
        {
            NFAState target;
            foreach (var trans in this.outgoing)
            {
                target = trans.State;
                if (initial && trans is NFAEpsilonTransition)
                {
                    target.MatchTransitions(ch, queue, true);
                }
                else if (trans.Match(ch))
                {
                    queue.AddLast(target);
                    if (target.epsilonOut)
                    {
                        target.MatchEmpty(queue);
                    }
                }
            }
        }

        /// <summary>
        /// Adds all the epsilon transition targets to the specified
        /// queue.
        /// </summary>
        /// <param name="queue">The state queue</param>
        public void MatchEmpty(NFAStateQueue queue)
        {
            NFAState target;

            foreach (var trans in this.outgoing)
            {
                if (trans is NFAEpsilonTransition)
                {
                    target = trans.State;
                    queue.AddLast(target);
                    if (target.epsilonOut)
                    {
                        target.MatchEmpty(queue);
                    }
                }
            }
        }

        /// <summary>
        /// Finds a unique character transition if one exists. The
        /// transition must be the only matching single character
        /// transition and no other transitions may reach the same
        /// state.
        /// </summary>
        /// <param name="ch">The character to search for</param>
        /// <returns>
        /// The unique transition state found, or null if none was found
        /// </returns>
        private NFAState FindUniqueCharTransition(char ch)
        {
            NFATransition res = null;

            foreach (var trans in this.outgoing)
            {
                if (trans.Match(ch) && trans is NFACharTransition)
                {
                    if (res != null)
                    {
                        return null;
                    }

                    res = trans;
                }
            }

            if (res == null)
            {
                return null;
            }

            foreach (var trans in this.outgoing)
            {
                if (trans != res && trans.State == res.State)
                {
                    return null;
                }
            }

            return (res == null) ? null : res.State;
        }
    }
}
