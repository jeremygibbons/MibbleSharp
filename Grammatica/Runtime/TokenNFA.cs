// <copyright file="TokenNFA.cs" company="None">
//    <para>
//    This program is free software: you can redistribute it and/or
//    modify it under the terms of the BSD license.</para>
//    <para>
//    This work is distributed in the hope that it will be useful, but
//    WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</para>
//    <para>
//    See the LICENSE.txt file for more details.</para>
//    Original code as generated by Grammatica 1.6 Copyright (c) 
//    2003-2015 Per Cederberg. All rights reserved.
//    Updates Copyright (c) 2016 Jeremy Gibbons. All rights reserved
// </copyright>

namespace PerCederberg.Grammatica.Runtime
{
    using System.Linq;
    using PerCederberg.Grammatica.Runtime.NFA;

    /// <summary>
    /// A non-deterministic finite state automaton (NFA) for matching
    /// tokens. It supports both fixed strings and simple regular
    /// expressions, but should perform similar to a DFA due to highly
    /// optimized data structures and tuning. The memory footprint during
    /// matching should be near zero, since no heap memory is allocated
    /// unless the pre-allocated queues need to be enlarged. The NFA also
    /// does not use recursion, but iterates in a loop instead.
    /// </summary>
    internal class TokenNFA
    {
        /// <summary>
        /// The initial state lookup table, indexed by the first ASCII
        /// character. This array is used to for speed optimizing the
        /// first step in the match, since the initial state would
        /// otherwise have a long list of transitions to consider.
        /// </summary> 
        private NFAState[] initialChar = new NFAState[128];

        /// <summary>
        /// The initial state. This state contains any transitions not
        /// already stored in the initial text state array, i.e. non-ASCII
        /// or complex transitions (such as regular expressions).
        /// </summary>
        private NFAState initial = new NFAState();

        /// <summary>
        /// The NFA state queue to use.
        /// </summary>
        private NFAStateQueue queue = new NFAStateQueue();

        /// <summary>
        /// Adds a string match to this automaton. New states and
        /// transitions will be added to extend this automaton to support
        /// the specified string.
        /// </summary>
        /// <param name="str">The string to match</param>
        /// <param name="ignoreCase">The case-insensitive match flag</param>
        /// <param name="value">The match value</param>
        public void AddTextMatch(string str, bool ignoreCase, TokenPattern value)
        {
            NFAState state;
            char ch = str[0];

            if (ch < 128 && !ignoreCase)
            {
                state = this.initialChar[ch];
                if (state == null)
                {
                    state = this.initialChar[ch] = new NFAState();
                }
            }
            else
            {
                state = this.initial.AddOut(ch, ignoreCase, null);
            }

            for (int i = 1; i < str.Length; i++)
            {
                state = state.AddOut(str[i], ignoreCase, null);
            }

            state.Value = value;
        }

        /// <summary>
        /// Adds a regular expression match to this automaton. New states
        /// and transitions will be added to extend this automaton to
        /// support the specified string. Note that this method only
        /// supports a subset of the full regular expression syntax, so
        /// a more complete regular expression library must also be
        /// provided.
        /// </summary>
        /// <param name="pattern">The regular expression string</param>
        /// <param name="ignoreCase">The case-insensitive match flag</param>
        /// <param name="value">The match value</param>
        /// <exception cref="Grammatica.RE.RegExpException">If the regular expression parsing 
        /// failed</exception>
        public void AddRegExpMatch(
            string pattern,
            bool ignoreCase,
            TokenPattern value)
        {
            TokenRegExpParser parser = new TokenRegExpParser(pattern, ignoreCase);
            string debug = "DFA regexp; " + parser.DebugInfo;
            bool isAscii;

            isAscii = parser.Start.IsAsciiOutgoing;
            for (int i = 0; isAscii && i < 128; i++)
            {
                bool match = false;
                foreach (var outTrans in parser.Start.Outgoing)
                {
                    if (outTrans.Match((char)i))
                    {
                        if (match)
                        {
                            isAscii = false;
                            break;
                        }

                        match = true;
                    }
                }

                if (match && this.initialChar[i] != null)
                {
                    isAscii = false;
                }
            }

            if (parser.Start.Incoming.Count > 0)
            {
                this.initial.AddOut(new NFAEpsilonTransition(parser.Start));
                debug += ", uses initial epsilon";
            }
            else if (isAscii && !ignoreCase)
            {
                for (int i = 0; isAscii && i < 128; i++)
                {
                    foreach (var outTrans in parser.Start.Outgoing)
                    {
                        if (outTrans.Match((char)i))
                        {
                            this.initialChar[i] = outTrans.State;
                        }
                    }
                }

                debug += ", uses ASCII lookup";
            }
            else
            {
                parser.Start.MergeInto(this.initial);
                debug += ", uses initial state";
            }

            parser.End.Value = value;
            value.DebugInfo = debug;
        }

        /// <summary>
        /// Checks if this NFA matches the specified input text. The
        /// matching will be performed from position zero (0) in the
        /// buffer. This method will not read any characters from the
        /// stream, just peek ahead.
        /// </summary>
        /// <param name="buffer">The input buffer to check</param>
        /// <param name="match">The token match to update</param>
        /// <returns>The number of characters matched</returns>
        /// <exception cref="System.IO.IOException">
        /// If an I/O error occurred
        /// </exception>
        public int Match(ReaderBuffer buffer, TokenMatch match)
        {
            int length = 0;
            int pos = 1;
            int peekChar;
            NFAState state;

            // The first step of the match loop has been unrolled and
            // optimized for performance below.
            this.queue.Clear();
            peekChar = buffer.Peek(0);

            if (peekChar >= 0 && peekChar < 128)
            {
                state = this.initialChar[peekChar];
                if (state != null)
                {
                    this.queue.AddLast(state);
                }
            }

            if (peekChar >= 0)
            {
                this.initial.MatchTransitions((char)peekChar, this.queue, true);
            }

            this.queue.MarkEnd();
            peekChar = buffer.Peek(1);

            // The remaining match loop processes all subsequent states
            while (!this.queue.Empty)
            {
                if (this.queue.Marked)
                {
                    pos++;
                    peekChar = buffer.Peek(pos);
                    this.queue.MarkEnd();
                }

                state = this.queue.RemoveFirst();

                if (state.Value != null)
                {
                    match.Update(pos, state.Value);
                }

                if (peekChar >= 0)
                {
                    state.MatchTransitions((char)peekChar, this.queue, false);
                }
            }

            return length;
        }
    }
}
