// <copyright file="Tokenizer.cs" company="None">
//    <para>
//    This program is free software: you can redistribute it and/or
//    modify it under the terms of the BSD license.</para>
//    <para>
//    This work is distributed in the hope that it will be useful, but
//    WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</para>
//    <para>
//    See the LICENSE.txt file for more details.</para>
//    Original code as generated by Grammatica 1.6 Copyright (c) 
//    2003-2015 Per Cederberg. All rights reserved.
//    Updates Copyright (c) 2016 Jeremy Gibbons. All rights reserved
// </copyright>

namespace PerCederberg.Grammatica.Runtime
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Text.RegularExpressions;
    using PerCederberg.Grammatica.Runtime.RE;

    /// <summary>
    /// A character stream tokenizer. This class groups the characters read
    /// from the stream together into tokens ("words"). The grouping is
    /// controlled by token patterns that contain either a fixed string to
    /// search for, or a regular expression. If the stream of characters
    /// don't match any of the token patterns, a parse exception is thrown.
    /// </summary>
    public class Tokenizer
    {
        /// <summary>
        /// The token list feature flag.
        /// </summary> 
        private bool useTokenList = false;

        /// <summary>
        /// The string DFA token matcher. This token matcher uses a
        /// deterministic finite automaton (DFA) implementation and is
        /// used for all string token patterns. It has a slight speed
        /// advantage to the NFA implementation, but should be equivalent
        /// on memory usage.
        /// </summary>
        private StringDFAMatcher stringDfaMatcher;

        /// <summary>
        /// The regular expression NFA token matcher. This token matcher
        /// uses a non-deterministic finite automaton (DFA) implementation
        /// and is used for most regular expression token patterns. It is
        /// somewhat faster than the other recursive regular expression
        /// implementations available, but doesn't support the full
        /// syntax. It conserves memory by using a fast queue instead of
        /// the stack during processing (no stack overflow).
        /// </summary>
        private NFAMatcher nfaMatcher;

        /// <summary>
        /// The regular expression token matcher. This token matcher is
        /// used for complex regular expressions, but should be avoided
        /// due to possibly degraded speed and memory usage compared to
        /// the automaton implementations.
        /// </summary>
        private RegExpMatcher regExpMatcher;

        /// <summary>
        /// The character stream reader buffer.
        /// </summary>
        private ReaderBuffer buffer = null;

        /// <summary>
        /// The last token match found.
        /// </summary>
        private TokenMatch lastMatch = new TokenMatch();

        /// <summary>
        /// The previous token in the token list.
        /// </summary>
        private Token previousToken = null;

        /// <summary>
        /// Initializes a new instance of the <see cref="Tokenizer"/> class, i.e. 
        /// a new case-sensitive tokenizer for the specified input stream.
        /// </summary>
        /// <param name="input">The input stream to read</param>
        public Tokenizer(TextReader input)
            : this(input, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Tokenizer"/> class
        /// for the specified input stream. The tokenizer can be set to process 
        /// tokens either in case-sensitive or case-insensitive mode.
        /// </summary>
        /// <param name="input">The input stream to read</param>
        /// <param name="ignoreCase">The character case ignore flag</param>
        public Tokenizer(TextReader input, bool ignoreCase)
        {
            this.stringDfaMatcher = new StringDFAMatcher(ignoreCase);
            this.nfaMatcher = new NFAMatcher(ignoreCase);
            this.regExpMatcher = new RegExpMatcher(ignoreCase);
            this.buffer = new ReaderBuffer(input);
        }

        /// <summary>
        /// Gets or sets a value indicating whether use a token list.
        /// If the token list flag is set, all tokens (including ignored 
        /// tokens) link to each other in a double-linked list. 
        /// By default the token list flag is set to false.
        /// </summary>
        /// <see cref="Token.Previous"/>
        /// <see cref="Token.Next"/>
        public bool UseTokenList
        {
            get
            {
                return this.useTokenList;
            }

            set
            {
                this.useTokenList = value;
            }
        }

        /// <summary>
        /// Gets the current line number. This number will be the line
        /// number of the next token returned.
        /// </summary>
        public int CurrentLine
        {
            get
            {
                return this.buffer.LineNumber;
            }
        }

        /// <summary>
        /// Gets the current column number. This number will be the
        /// column number of the next token returned.
        /// </summary>
        public int CurrentColumn
        {
            get
            {
                return this.buffer.ColumnNumber;
            }
        }

        /// <summary>
        /// Returns a description of the token pattern with the
        /// specified id.
        /// </summary>
        /// <param name="id">The token pattern id</param>
        /// <returns>The token pattern description, or null if not present</returns>
        public string GetPatternDescription(int id)
        {
            TokenPattern pattern;

            pattern = this.stringDfaMatcher.GetPattern(id);

            if (pattern == null)
            {
                pattern = this.nfaMatcher.GetPattern(id);
            }

            if (pattern == null)
            {
                pattern = this.regExpMatcher.GetPattern(id);
            }

            return (pattern == null) ? null : pattern.ToShortString();
        }

        /// <summary>
        /// Adds a new token pattern to the tokenizer. The pattern will be
        /// added last in the list, choosing a previous token pattern in
        /// case two matches the same string.
        /// </summary>
        /// <param name="pattern">The pattern to add</param>
        /// <exception cref="ParserCreationException">
        /// If the pattern couldn't be added to the tokenizer
        /// </exception>
        public void AddPattern(TokenPattern pattern)
        {
            switch (pattern.Type)
            {
                case TokenPattern.PatternType.String:
                    try
                    {
                        this.stringDfaMatcher.AddPattern(pattern);
                    }
                    catch (Exception e)
                    {
                        throw new ParserCreationException(
                            ParserCreationException.ErrorType.InvalidToken,
                            pattern.Name,
                            "error adding string token: " +
                            e.Message);
                    }

                    break;
                case TokenPattern.PatternType.RegExp:
                    try
                    {
                        this.nfaMatcher.AddPattern(pattern);
                    }
                    catch (Exception)
                    {
                        try
                        {
                            this.regExpMatcher.AddPattern(pattern);
                        }
                        catch (Exception e)
                        {
                            throw new ParserCreationException(
                                ParserCreationException.ErrorType.InvalidToken,
                                pattern.Name,
                                "regular expression contains error(s): " +
                                e.Message);
                        }
                    }

                    break;
                default:
                    throw new ParserCreationException(
                        ParserCreationException.ErrorType.InvalidToken,
                        pattern.Name,
                        "pattern type " + pattern.Type + " is undefined");
            }
        }

        /// <summary>
        /// Resets this tokenizer for usage with another input stream.
        /// This method will clear all the internal state in the
        /// tokenizer as well as close the previous input stream. It
        /// is normally called in order to reuse a parser and
        /// tokenizer pair with multiple input streams, thereby
        /// avoiding the cost of re-analyzing the grammar structures.
        /// </summary>
        /// <param name="input">The new input stream to read</param>
        /// <see cref="Parser.Reset(TextReader)"/>
        public void Reset(TextReader input)
        {
            this.buffer.Reset();
            this.buffer = new ReaderBuffer(input);
            this.previousToken = null;
            this.lastMatch.Clear();
        }

        /// <summary>
        /// Finds the next token on the stream. This method will return
        /// null when end of file has been reached. It will return a
        /// parse exception if no token matched the input stream, or if
        /// a token pattern with the error flag set matched. Any tokens
        /// matching a token pattern with the ignore flag set will be
        /// silently ignored and the next token will be returned.
        /// </summary>
        /// <returns>The next token found, or null if end of file was encountered</returns>
        /// <exception cref="ParseException">
        /// If the input stream couldn't be read or parsed correctly
        /// </exception>
        public Token Next()
        {
            Token token = null;

            do
            {
                token = this.NextToken();
                if (token == null)
                {
                    this.previousToken = null;
                    return null;
                }

                if (this.useTokenList)
                {
                    token.Previous = this.previousToken;
                    this.previousToken = token;
                }

                if (token.Pattern.Ignore)
                {
                    token = null;
                }
                else if (token.Pattern.Error)
                {
                    throw new ParseException(
                        ParseException.ErrorType.InvalidToken,
                        token.Pattern.ErrorMessage,
                        token.StartLine,
                        token.StartColumn);
                }
            }
            while (token == null);

            return token;
        }

        /// <summary>
        /// Returns a string representation of this object. The returned
        /// string will contain the details of all the token patterns
        /// contained in this tokenizer.
        /// </summary>
        /// <returns>A detailed string representation</returns>
        public override string ToString()
        {
            StringBuilder builder = new StringBuilder();

            builder.Append(this.stringDfaMatcher);
            builder.Append(this.nfaMatcher);
            builder.Append(this.regExpMatcher);
            return builder.ToString();
        }

        /// <summary>
        /// Factory method for creating a new token. This method can be
        /// overridden to provide other token implementations than the
        /// default one.
        /// </summary>
        /// <param name="pattern">The token pattern</param>
        /// <param name="image">The token image (i.e. characters)</param>
        /// <param name="line">The line number of the first character</param>
        /// <param name="column">The column number of the first character</param>
        /// <returns>The created token</returns>
        protected virtual Token NewToken(
            TokenPattern pattern,
            string image,
            int line,
            int column)
        {
            return new Token(pattern, image, line, column);
        }

        /// <summary>
        /// Finds the next token on the stream. This method will return
        /// null when end of file has been reached. It will return a
        /// parse exception if no token matched the input stream.
        /// </summary>
        /// <returns>The next token found, or null if EOF was encountered</returns>
        /// <exception cref="ParseException">
        /// If the input stream couldn't be read or parsed correctly
        /// </exception>
        private Token NextToken()
        {
            string str;
            int line;
            int column;

            try
            {
                this.lastMatch.Clear();
                this.stringDfaMatcher.Match(this.buffer, this.lastMatch);
                this.nfaMatcher.Match(this.buffer, this.lastMatch);
                this.regExpMatcher.Match(this.buffer, this.lastMatch);
                if (this.lastMatch.Length > 0)
                {
                    line = this.buffer.LineNumber;
                    column = this.buffer.ColumnNumber;
                    str = this.buffer.Read(this.lastMatch.Length);
                    return this.NewToken(this.lastMatch.Pattern, str, line, column);
                }
                else if (this.buffer.Peek(0) < 0)
                {
                    return null;
                }
                else
                {
                    line = this.buffer.LineNumber;
                    column = this.buffer.ColumnNumber;
                    throw new ParseException(
                        ParseException.ErrorType.UnexpectedChar,
                        this.buffer.Read(1),
                        line,
                        column);
                }
            }
            catch (IOException e)
            {
                throw new ParseException(
                    ParseException.ErrorType.IO,
                    e.Message,
                    -1,
                    -1);
            }
        }

        /// <summary>
        /// A token pattern matcher. This class is the base class for the
        /// various types of token matchers that exist. The token matcher
        /// checks for matches with the tokenizer buffer, and maintains the
        /// state of the last match.
        /// </summary>
        internal abstract class TokenMatcher
        {
            /// <summary>
            /// The array of token patterns.
            /// </summary>
            private IList<TokenPattern> patterns = new List<TokenPattern>();

            /// <summary>
            /// The ignore character case flag.
            /// </summary>
            private bool ignoreCase = false;

            /// <summary>
            /// Initializes a new instance of the <see cref="TokenMatcher"/> class.
            /// </summary>
            /// <param name="ignoreCase">The character case ignore flag</param>
            public TokenMatcher(bool ignoreCase)
            {
                this.ignoreCase = ignoreCase;
            }

            /// <summary>
            /// Gets a value indicating whether to ignore case
            /// </summary>
            protected bool IgnoreCase
            {
                get
                {
                    return this.ignoreCase;
                }
            }

            /// <summary>
            /// Gets the list of patterns
            /// </summary>
            protected IList<TokenPattern> Patterns
            {
                get
                {
                    return this.patterns;
                }
            }

            /// <summary>
            /// Searches for matching token patterns at the start of the
            /// input stream. If a match is found, the token match object
            /// is updated.
            /// </summary>
            /// <param name="buffer">The input buffer to check</param>
            /// <param name="match">The token match to update</param>
            /// <exception cref="IOException">If an I/O error occurred</exception>
            public abstract void Match(ReaderBuffer buffer, TokenMatch match);

            /// <summary>
            /// Returns the token pattern with the specified id. Only
            /// token patterns handled by this matcher can be returned.
            /// </summary>
            /// <param name="id">The token pattern id</param>
            /// <returns>The token pattern found, or null if not found</returns>
            public TokenPattern GetPattern(int id)
            {
                return this.patterns.Where(p => p.Id == id).SingleOrDefault();
            }

            /// <summary>
            /// Adds a string token pattern to this matcher.
            /// </summary>
            /// <param name="pattern">The pattern to add</param>
            /// <exception cref="Exception">If the pattern couldn't be added to the matcher</exception>
            public virtual void AddPattern(TokenPattern pattern)
            {
                this.patterns.Add(pattern);
            }

            /// <summary>
            /// Returns a string representation of this matcher. This will
            /// contain all the token patterns.
            /// </summary>
            /// <returns>A detailed string representation of this matcher</returns>
            public override string ToString()
            {
                StringBuilder buffer = new StringBuilder();

                foreach (var p in this.patterns)
                {
                    buffer.Append(p);
                    buffer.Append("\n\n");
                }

                return buffer.ToString();
            }
        }

        /// <summary>
        /// A token pattern matcher using a DFA for string tokens. This
        /// class only supports string tokens and must be complemented
        /// with another matcher for regular expressions. Internally it
        /// uses a DFA to provide high performance.
        /// </summary>
        internal class StringDFAMatcher : TokenMatcher
        {
            /// <summary>
            /// The deterministic finite state automaton used for
            /// matching.
            /// </summary>
            private TokenStringDFA automaton = new TokenStringDFA();

            /// <summary>
            /// Initializes a new instance of the <see cref="StringDFAMatcher"/> class.
            /// </summary>
            /// <param name="ignoreCase">The character case ignore flag</param>
            public StringDFAMatcher(bool ignoreCase) : base(ignoreCase)
            {
            }

            /// <summary>
            /// Adds a string token pattern to this matcher.
            /// </summary>
            /// <param name="pattern">The pattern to add</param>
            public override void AddPattern(TokenPattern pattern)
            {
                this.automaton.AddMatch(pattern.Pattern, this.IgnoreCase, pattern);
                base.AddPattern(pattern);
            }

            /// <summary>
            /// Searches for matching token patterns at the start of the
            /// input stream. If a match is found, the token match object
            /// is updated.
            /// </summary>
            /// <param name="buffer">The input buffer to check</param>
            /// <param name="match">The token match to update</param>
            /// <exception cref="IOException">If an error occurred</exception>
            public override void Match(ReaderBuffer buffer, TokenMatch match)
            {
                TokenPattern res = this.automaton.Match(buffer, this.IgnoreCase);

                if (res != null)
                {
                    match.Update(res.Pattern.Length, res);
                }
            }
        }

        /// <summary>
        /// A token pattern matcher using a NFA for both string and
        /// regular expression tokens. This class has limited support for
        /// regular expressions and must be complemented with another
        /// matcher providing full regular expression support. Internally
        /// it uses a NFA to provide high performance and low memory
        /// usage.
        /// </summary>
        internal class NFAMatcher : TokenMatcher
        {
            /// <summary>
            /// The non-deterministic finite state automaton used for
            /// matching.
            /// </summary>
            private TokenNFA automaton = new TokenNFA();

            /// <summary>
            /// Initializes a new instance of the <see cref="NFAMatcher"/> class.
            /// </summary>
            /// <param name="ignoreCase">The character case ignore flag</param>
            public NFAMatcher(bool ignoreCase) : base(ignoreCase)
            {
            }

            /// <summary>
            /// Adds a token pattern to this matcher.
            /// </summary>
            /// <param name="pattern">The pattern to add</param>
            /// <exception cref="Exception">
            /// If the pattern couldn't be added to the matcher
            /// </exception>
            public override void AddPattern(TokenPattern pattern)
            {
                if (pattern.Type == TokenPattern.PatternType.String)
                {
                    this.automaton.AddTextMatch(pattern.Pattern, this.IgnoreCase, pattern);
                }
                else
                {
                    this.automaton.AddRegExpMatch(pattern.Pattern, this.IgnoreCase, pattern);
                }

                base.AddPattern(pattern);
            }

            /// <summary>
            /// Searches for matching token patterns at the start of the
            /// input stream. If a match is found, the token match object
            /// is updated.
            /// </summary>
            /// <param name="buffer">The input buffer to check</param>
            /// <param name="match">The token match to update</param>
            /// <exception cref="IOException">If an I/O error occurred</exception>
            public override void Match(ReaderBuffer buffer, TokenMatch match)
            {
                this.automaton.Match(buffer, match);
            }
        }

        /// <summary>
        /// A token pattern matcher for complex regular expressions. This
        /// class only supports regular expression tokens and must be
        /// complemented with another matcher for string tokens.
        /// Internally it uses the <c>GrammaticaRE</c> package for high
        /// performance or the native .NET package for maximum
        /// compatibility.
        /// </summary>
        internal class RegExpMatcher : TokenMatcher
        {
            /// <summary>
            /// The regular expression handlers.
            /// </summary>
            private REHandler[] regExps = new REHandler[0];

            /// <summary>
            /// Initializes a new instance of the <see cref="RegExpMatcher"/> class.
            /// </summary>
            /// <param name="ignoreCase">The character case ignore flag</param>
            public RegExpMatcher(bool ignoreCase) : base(ignoreCase)
            {
            }

            /// <summary>
            /// Adds a regular expression token pattern to this matcher.
            /// </summary>
            /// <param name="pattern">The pattern to add</param>
            /// <exception cref="Exception">
            /// If the pattern couldn't be added to the matcher
            /// </exception>
            public override void AddPattern(TokenPattern pattern)
            {
                REHandler re;

                try
                {
                    re = new GrammaticaRE(pattern.Pattern, this.IgnoreCase);
                    pattern.DebugInfo = "Grammatica regexp\n" + re;
                }
                catch (Exception)
                {
                    re = new SystemRE(pattern.Pattern, this.IgnoreCase);
                    pattern.DebugInfo = "native .NET regexp";
                }

                Array.Resize(ref this.regExps, this.regExps.Length + 1);
                this.regExps[this.regExps.Length - 1] = re;
                base.AddPattern(pattern);
            }

            /// <summary>
            /// Searches for matching token patterns at the start of the
            /// input stream. If a match is found, the token match object
            /// is updated.
            /// </summary>
            /// <param name="buffer">The input buffer to check</param>
            /// <param name="match">The token match to update</param>
            /// <exception cref="IOException">If an I/O error occurred</exception>
            public override void Match(ReaderBuffer buffer, TokenMatch match)
            {
                for (int i = 0; i < this.regExps.Length; i++)
                {
                    int length = this.regExps[i].Match(buffer);
                    if (length > 0)
                    {
                        match.Update(length, this.Patterns[i]);
                    }
                }
            }
        }

        /// <summary>
        /// The regular expression handler base class.
        /// </summary>
        internal abstract class REHandler
        {
            /// <summary>
            /// Checks if the start of the input stream matches this
            /// regular expression.
            /// </summary>
            /// <param name="buffer">The input buffer to check</param>
            /// <returns>The longest match found, or 0 if none was found</returns>
            /// <exception cref="IOException">If an I/O error occurred</exception>
            public abstract int Match(ReaderBuffer buffer);
        }

        /// <summary>
        /// The Grammatica built-in regular expression handler.
        /// </summary>
        internal class GrammaticaRE : REHandler
        {
            /// <summary>
            /// The compiled regular expression.
            /// </summary>
            private RegExp regExp;

            /// <summary>
            /// The regular expression matcher to use.
            /// </summary>
            private Matcher matcher = null;

            /// <summary>
            /// Initializes a new instance of the <see cref="GrammaticaRE"/> class.
            /// </summary>
            /// <param name="regex">The regular expression text</param>
            /// <param name="ignoreCase">The character case ignore flag</param>
            /// <exception cref="Exception">
            /// If the regular expression contained invalid syntax
            /// </exception>
            public GrammaticaRE(string regex, bool ignoreCase)
            {
                this.regExp = new RegExp(regex, ignoreCase);
            }

            /// <summary>
            /// Checks if the start of the input stream matches this
            /// regular expression.
            /// </summary>
            /// <param name="buffer">The input buffer to check</param>
            /// <returns>The longest match found, or 0 if none was found</returns>
            /// <exception cref="IOException">If an I/O error occurred</exception>
            public override int Match(ReaderBuffer buffer)
            {
                if (this.matcher == null)
                {
                    this.matcher = this.regExp.Matcher(buffer);
                }
                else
                {
                    this.matcher.Reset(buffer);
                }

                return this.matcher.MatchFromBeginning() ? this.matcher.Length : 0;
            }
        }

        /// <summary>
        /// The .NET system regular expression handler.
        /// </summary>
        internal class SystemRE : REHandler
        {
            /// <summary>
            /// The parsed regular expression.
            /// </summary>
            private Regex reg;

            /// <summary>
            /// Initializes a new instance of the <see cref="SystemRE"/> class, i.e.
            /// a new .NET system regular expression handler.
            /// </summary>
            /// <param name="regex">The regular expression text</param>
            /// <param name="ignoreCase">The character case ignore flag</param>
            /// <exception cref="Exception">If the regular expression contained invalid syntax</exception>
            public SystemRE(string regex, bool ignoreCase)
            {
                if (ignoreCase)
                {
                    this.reg = new Regex(regex, RegexOptions.IgnoreCase);
                }
                else
                {
                    this.reg = new Regex(regex);
                }
            }

            /// <summary>
            /// Checks if the start of the input stream matches this
            /// regular expression.
            /// </summary>
            /// <param name="buffer">The input buffer to check</param>
            /// <returns>The longest match found, or 0 if no match was found</returns>
            /// <exception cref="IOException">If an I/O error occurred</exception>
            public override int Match(ReaderBuffer buffer)
            {
                Match m;

                // Ugly hack since .NET doesn't have a flag for when the
                // end of the input string was encountered...
                buffer.Peek(1024 * 16);

                // Also, there is no API to limit the search to the specified
                // position, so we double-check the index afterwards instead.
                m = this.reg.Match(buffer.ToString(), buffer.Position);

                if (m.Success && m.Index == buffer.Position)
                {
                    return m.Length;
                }
                else
                {
                    return 0;
                }
            }
        }
    }
}
